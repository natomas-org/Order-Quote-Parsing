# -*- coding: utf-8 -*-
"""CSVParse.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GmosbNAiQn64Yv_S-d_RvX4hezg-mFb_
"""

#initialization
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import data_table
import csv

CLIENT_NAME = "Clark"

!pip install git+https://github.com/pdftables/python-pdftables-api.git
import pdftables_api
c = pdftables_api.Client('88ilr7h6pqui')
c.csv(CLIENT_NAME + '_Quote.pdf', CLIENT_NAME + '_Quote.csv')

#docusign parsing
rows_to_skip = 19;
with open('/content/' + CLIENT_NAME + '_Quote.csv') as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    for row in csv_reader:
      current_row = row;
      for elem in current_row:
        if("DocuSign" in elem):
          rows_to_skip = 20;

#header prep
header_names_important = ["Feature", "Option", "Variant", "Description", "Unnamed: 4", "Quantity", "Ext. Price", "Unnamed: 7", "Unnamed: 8"];
header_names_arbitrary_raw = range(9,50);
header_names_arbitrary = [];
for x in header_names_arbitrary_raw:
  header_names_arbitrary.append(str(x));
header_names = header_names_important + header_names_arbitrary


#Data Import
original_file_name = '/content/' + CLIENT_NAME + '_Quote.csv';
df = pd.read_csv(original_file_name,delimiter=',', header = None, names = header_names, skiprows=rows_to_skip, engine = 'python');
total_categories = ["Miscellaneous", "Construction", "Frame", "Floor", "Floor Covering", "Plumbing/Heating", "Utility Room", "Electrical", "Walls", "Roof", "Exterior", "Exterior Doors", "Windows", "Cabinets", "Cabinet Doors", "Countertop", "Backsplash", "Appliances", "Kitchen", "Master Bath", "Second Bath", "Lighting", "Interior", "Interior Doors", "Program & Fees", "Shipped Loose Material", "Window Covering", "Inflation Protection Plan", "MISCELLANEOUS CHARGES"];

#save each relevent row and convert type to strings
features_raw = df['Feature']
features = [];
for f in features_raw:
  features.append(str(f));

options_raw = df['Option']
options = [];
for o in options_raw:
  options.append(str(o));

variants_raw = df['Variant']
variants = [];
for v in variants_raw:
  variants.append(str(v));

descriptions_raw = df['Description']
descriptions = [];
for d in descriptions_raw:
  descriptions.append(str(d));

quantities_raw = df['Quantity'];
quantities = [];
for q in quantities_raw:
  quantities.append(str(q));

prices_raw = df['Ext. Price'];
prices = [];
for p in prices_raw:
  prices.append(str(p));

extra_column_raw = df["Unnamed: 4"];
extra_column = [];
for e in extra_column_raw:
 extra_column.append(str(e));

extra_column_1_raw = df["Unnamed: 7"];
extra_column_1 = [];
for e1 in extra_column_1_raw:
 extra_column_1.append(str(e1));

extra_column_2_raw = df["Unnamed: 8"];
extra_column_2 = [];
for e2 in extra_column_2_raw:
 extra_column_2.append(str(e2));

#find the relevent indices in the imported data, IE the rows containing features and descriptions
indices = [];
for i in range(1,len(features)):
  if( not (features[i] == "nan") and not ("Quote" in features[i]) and not ("Champion" in features[i]) and not ("..." in features[i]) and not ("Feature" in features[i]) and not ("DocuSign" in features[i])):
    indices.append(i);

#remove all rows after SURCHARGE row in new array of all relevent indices
for i in indices:
  if(features[i] == "SURCHARGE"):
    surcharge_index = i;
for i in range(surcharge_index+1, surcharge_index+15):
  if("OP" in options[i] or "SP" in options[i]):
    surcharge_index = i;
feature_indices = [x for x in indices if x <= surcharge_index];

#process the quantity and price sections, ensure that all prices are in the price section and all quantities are in the quantity section
for i in indices:
  if (quantities[i]=="nan"):
    if (prices[i]=="nan"):
      quantities[i] = extra_column_1[i];
      prices[i] = extra_column_2[i];
    else:
      quantities[i] = prices[i];
      prices[i] = extra_column_1[i];
  
#in some cases, the quantity and price of the final lines occur dozens of columns to the right (Kuo Issue)
#this code will rectify that by first identifying each troublesome row:
kuo_indices = [];
for i in feature_indices:
  if(quantities[i] == "nan" and prices[i] == "nan"):
    kuo_indices.append(i);
# next I have to iterate through each index, and find the first index in the row after index 7 that contains some non empty string, 
# and setting that to the quantity of that row, and finding the second non empty string and setting that to the price of each row
for k in kuo_indices:
  row_raw = df.iloc[k].values;
  row=[];
  for r in row_raw:
    row.append(str(r));
  for i in range(7, len(row)):
    if(not (row[i] == "nan") and (quantities[k] == "nan")):
      quantities[k] = row[i];
      row[i] = "nan";
  for i in range(7,len(row)):
    if("." in row[i] and prices[k] == "nan"):
      prices[k] = row[i];
      row[i] = "nan";

#process the blank column after description
for i in range(0,len(descriptions)):
 if((not (extra_column[i] == "nan")) and ((descriptions[i] == "nan") or (descriptions[i] == "/"))):
   descriptions[i] = extra_column[i];
 if("$" in descriptions and "." in descriptions):
   options[i] = options[i] + descriptions[i];
   descriptions[i] = "";


#finds the indices of all notes in the options section
note_indices = [];
for i in range(1,len(features)):
  if( not (options[i] == "nan") and not ("OP0" in features[i]) and not ("OP1" in features[i]) and not ("OP2" in features[i]) and not ("OP3" in features[i]) and not ("OP4" in features[i]) and not ("OP5" in features[i]) and not ("OP6" in features[i]) and not ("OP7" in features[i]) and not ("OP8" in features[i]) and not ("OP9" in features[i]) and not ("SO0" in features[i]) and not ("SO1" in features[i]) and not ("SO2" in features[i]) and not ("SO3" in features[i]) and not ("SO4" in features[i]) and not ("SO5" in features[i]) and not ("SO6" in features[i]) and not ("SO7" in features[i]) and not ("SO8" in features[i]) and not ("SO9" in features[i])  ):
    note_indices.append(i);


#find the indices at which the section descriptions are, IE MISC, Frame, ETC
#also generate a list of all categories used in the quote, excluding "Continued..." sections
category_indices = [];
categories = [];
for i in range(0,len(descriptions)):
  for name in total_categories:
    if(descriptions[i] == name):
      category_indices.append(i);
      categories.append(name);

change_array = [];
element_changed_index = 0;
for i in range(0,surcharge_index+1):
  if(i in feature_indices):
    change = [];
    for j in range(1,len(category_indices)):
      if ( (i > category_indices[j-1]) and (i < category_indices[j])):
        change.append(categories[j-1]);
    if not change:
      change.append(categories[len(categories)-1]);
    change.append(features[i]);
    change.append(options[i]);
    if(not (variants[i] == "nan")):
      change.append(variants[i]);
    else:
      change.append("N/A");
    change.append(descriptions[i]);
    change.append(quantities[i]);
    change.append(prices[i]);
    element_changed_index = element_changed_index + 1;
    change_array.append(change);
  elif(i in note_indices):
    change_array[element_changed_index-1].append(options[i]);

#final checks
for row in change_array:
  if (row[6]=="nan"):
    row[6] = "N/A";
  if(row[4] == "nan"):
    row[4] = row[3];
    row[3] = "N/A";

if(not options[surcharge_index+1] == "nan"):
  change_array[len(change_array)-1].append(options[surcharge_index+1]);

header = ["Category", "Feature", "Option", "Variant", "Description", "Quantity", "Ext. Price", "Description Notes ->"]

# open the file in the write mode
f = open('/content/' + CLIENT_NAME + '_Quote_Processed.csv', 'w')

# create the csv writer
writer = csv.writer(f)

# write a row to the csv file
writer.writerow(header)
for row in change_array:
  writer.writerow(row);


# close the file
f.close()

#pip install tabula-py

#import tabula

# df = tabula.read_pdf("/content/Sterba_Quote.pdf", pages='all')
#tabula.convert_into("/content/Sterba_Quote.pdf", "/content/Sterba_Quote2.csv", output_format="csv", pages='all')

